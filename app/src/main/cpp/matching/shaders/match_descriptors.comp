#version 450

// Workgroup size is set via Vulkan specialization constant at pipeline creation.
// Valid values: 64, 128, 256. Default 256 if not overridden.
layout(constant_id = 0) const uint WORKGROUP_SIZE = 256;
layout(local_size_x_id = 0) in;

layout(push_constant) uniform PushConstants {
    uint n1;  // number of descriptors in set 1
    uint n2;  // number of descriptors in set 2
};

// Descriptor buffers: flat float arrays, 64 floats per descriptor
layout(set = 0, binding = 0) readonly buffer Desc1 { float desc1[]; };
layout(set = 0, binding = 1) readonly buffer Desc2 { float desc2[]; };

// Output: per-descriptor in set 1
layout(set = 0, binding = 2) writeonly buffer MatchIndices   { int   match_indices[];   };
layout(set = 0, binding = 3) writeonly buffer MatchDistances { float match_distances[];  };
layout(set = 0, binding = 4) writeonly buffer SecondDists    { float second_distances[]; };

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= n1) return;

    uint base1 = idx * 64u;

    // Cache desc1[idx] into registers — read once from global memory instead of n2 times
    vec4 d1_cache[16];
    for (uint k = 0u; k < 16u; ++k) {
        uint off = base1 + k * 4u;
        d1_cache[k] = vec4(desc1[off], desc1[off + 1u], desc1[off + 2u], desc1[off + 3u]);
    }

    float best_dist   = 3.402823466e+38;  // FLT_MAX
    float second_dist = 3.402823466e+38;
    int   best_idx    = -1;

    for (uint j = 0u; j < n2; ++j) {
        uint base2 = j * 64u;
        float dist = 0.0;
        bool early_out = false;

        // vec4 accumulation with dot() builtin + early termination
        for (uint k = 0u; k < 16u; ++k) {
            uint off = base2 + k * 4u;
            vec4 d2 = vec4(desc2[off], desc2[off + 1u], desc2[off + 2u], desc2[off + 3u]);
            vec4 diff = d1_cache[k] - d2;
            dist += dot(diff, diff);

            // Early termination: if partial distance already exceeds second-best,
            // this candidate cannot become best or second-best — skip remaining dims
            if (dist >= second_dist) {
                early_out = true;
                break;
            }
        }

        if (early_out) continue;

        if (dist < best_dist) {
            second_dist = best_dist;
            best_dist = dist;
            best_idx = int(j);
        } else if (dist < second_dist) {
            second_dist = dist;
        }
    }

    match_indices[idx]   = best_idx;
    match_distances[idx] = best_dist;
    second_distances[idx] = second_dist;
}
